Problems:
I had some problems with installing kafka, as there werent a lot of documentation for NixOS. But eventually I was able to find a configuration that worked and didnt need zookeeper.
I was looking into how to run kafka and found you can run it in a docker, but I decided to just run it directly on my system. This is linked to the problem on the line over, and I used a config I found on the nix forums. It is this config:
services.apache-kafka = {
  enable = true; # This means that everytime I turn on my computer kafka will be running as a systemd service, unless i switch this to false and do a nixos-rebuild.
  clusterId = "generated a cluserid by using creating a temporary nix shell";
  formatLogDirs = true;
  settings = {
    listeners = [
      "PLAINTEXT://:9092"
      "CONTROLLER://:9093"
    ];
    "listener.security.protocol.map" = [
      "PLAINTEXT:PLAINTEXT"
      "CONTROLLER:PLAINTEXT"
    ];
    "controller.quorum.voters" = [
      "1@127.0.0.1:9093"
    ];
    "controller.listener.names" = ["CONTROLLER"];
    "node.id" = 1;
    "process.roles" = ["broker" "controller"];
    "log.dirs" = ["/var/lib/apache-kafka"];
    "offsets.topic.replication.factor" = 1;
    "transaction.state.log.replication.factor" = 1;
    "transaction.state.log.min.isr" = 1;
  };
};

I ran into a Kafka consumer group rebalance. This caused a big delay when votes on different polls were cast. For example if I voted on poll 1 a few times, then everything updated almost straight away. But if I then votes on a poll with a different id the consumer registers that a new task arrives. This change of "job" is the rebalance and made everything a lot slower. I suppose for a project like this it isnt a big problem.


I ran into a problem because using REST API only with the messaging in the way I had initially thought doesnt really make a lot of sense. Because if there are multiple users on the site, and one of them casts a vote, then the others wont see it unless they also make a request to the api. So the application wont actually be in real time, which is way less cool. A multi user application that updates in real time is much cooler.